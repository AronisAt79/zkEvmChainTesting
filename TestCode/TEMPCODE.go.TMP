if showBal {

	bal := GetBalances(_accounts, *ethcl1, *ethcl2, _ctx)
	for _, b := range bal {
		fmt.Printf("account %x has %v funds in l2 and %v funds in l1\n", b.hexaddr, b.layer2Funds, b.layer1Funds)

	}
}

if initL2Funds {

	bridgeAddress := common.HexToAddress(lOnebridge)
	bridge, err := zkevml1bridge.NewZkevml1bridge(bridgeAddress, ethcl1)
	if err != nil {
		fmt.Println(err)
		log.Fatal(err)
	}
	fmt.Println("starting deposits")
	zeros = append(zeros, big.NewInt(0))

	for len(zeros) != 0 {
		zeros = nil
		// Generate zkevml1bridge.DispatchMessage inputs, deposit 1/10000 to l2
		disMsgData, si, _ := NewDmsgData(&ks, miner, 100000, _accounts, *ethcl1, _ctx, r, l1ChainId)
		fmt.Printf("account : %x || nonce: %v\n", _accounts[si].Address, disMsgData._nonce)
		//Send transaction with generated bind.TransactOpts
		tx, err := bridge.DispatchMessage(disMsgData._txOpts, disMsgData._to, disMsgData._fee, disMsgData._deadline, disMsgData._nonce, disMsgData._data)
		if err != nil {
			fmt.Println(err)
			// log.Fatal(err)
		}

		fmt.Printf("TxHash: %v\n", tx.Hash())
		TxHashes = append(TxHashes, tx.Hash())

		// fmt.Printf("TxCost: %v\n\n\n", tx.Cost())

		errr := ethcl1.SendTransaction(_ctx, tx)
		if errr != nil {
			fmt.Println(errr)
			// log.Fatal(err)
		}

		bal := GetBalances(_accounts, *ethcl1, *ethcl2, _ctx)
		for _, b := range bal {
			if b.layer2Funds.Cmp(big.NewInt(0)) == 0 {
				zeros = append(zeros, b.layer2Funds)
				// fmt.Println("true")
			}

		}

	}

	fmt.Printf("number of transactions sent: %v\n", len(TxHashes))
	fmt.Println(TxHashes)
}

if doTxs {
	ethcl, err := ethclient.Dial(tnEnv[testEnv+"_L"+strlayer])
	if err != nil {
		fmt.Println(err)
		log.Fatal(err)
	}
	chainId, err := ethcl.NetworkID(_ctx)
	if err != nil {
		fmt.Println(err)
		log.Fatal(err)
	}

	for ii := 1; ii <= TxCount; ii++ {
		newtxdata, si, _ := NewTxData(_accounts, *ethcl, _ctx, r)
		newtx := NewTx(newtxdata)
		signedTx, err := ks.SignTxWithPassphrase(_accounts[si], passw0rd, newtx, chainId)
		// fmt.Printf("Chain ID: %v\n", chainId)
		if err != nil {
			fmt.Println(err)
			// log.Fatal(err)
		}

		// fmt.Printf("L%v Tx: account %x wants to send %v to account %x\n",layer, _accounts[si].Address, newtxdata._amount, _accounts[ri].Address)
		// fmt.Printf("Tx Hash: %v\n", signedTx.Hash())
		fmt.Printf("Account Nonce: %v\n", newtxdata._nonce)
		err = ethcl.SendTransaction(_ctx, signedTx)
		if err != nil {
			fmt.Println(err)
			// log.Fatal(err)
		}

		// fmt.Printf("Sleeping for %v\n", TxSl)
		// time.Sleep(TxSl * time.Second)
		time.Sleep(TxSl)
		fmt.Printf("Sent %v Txs so far\n", ii)
	}
}

if doWithDraws {
	strlayer = "2"
	ethcl, err := ethclient.Dial(tnEnv[testEnv+"_L"+strlayer])
	if err != nil {
		fmt.Println(err)
		log.Fatal(err)
	}
	chainId, err := ethcl.NetworkID(_ctx)
	if err != nil {
		fmt.Println(err)
		log.Fatal(err)
	}

	bridgeAddress := common.HexToAddress(lTwobridge)
	bridge, err := zkevmmessagedispatcher.NewZkevmmessagedispatcher(bridgeAddress, ethcl)
	if err != nil {
		fmt.Println(err)
		log.Fatal(err)
	}

	// ii := 0
	// TxHashes = nil
	for ii := 1; ii <= TxCount; ii++ {
		disMsgData, si, _ := NewDmsgData(&ks, miner, 1000000, _accounts, *ethcl, _ctx, r, chainId)
		fmt.Printf("account : %x || nonce: %v\n", _accounts[si].Address, disMsgData._nonce)
		//Send transaction with generated bind.TransactOpts
		tx, err := bridge.DispatchMessage(disMsgData._txOpts, disMsgData._to, disMsgData._fee, disMsgData._deadline, disMsgData._nonce, disMsgData._data)
		if err != nil {
			fmt.Println(err)
			// log.Fatal(err)
		}

		// fmt.Printf("TxHash: %v\n %v", tx, ii)
		fmt.Printf("TxHash: %v\n %v\n", tx.Hash(), ii)
		TxHashes = append(TxHashes, tx.Hash())

		// fmt.Printf("TxCost: %v\n\n\n", tx.Cost())

		errr := ethcl.SendTransaction(_ctx, tx)
		if errr != nil {
			fmt.Printf("ERROR: %v\n", errr)
			// log.Fatal(err)
		}

		// time.Sleep(2 * time.Second)
		time.Sleep(TxSl)
		// ii += 1
		fmt.Printf("Sent %v Txs so far\n", ii)
	}

}
